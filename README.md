# ПОЯСНИТЕЛЬНАЯ ЗАПИСКА

## Введение

Основная цель работы - ???

Во всех реализация xUnit предоставляется базовый набор функций, которые позволяют решать следующие задачи:

* описывать тест как тестовый метод (Test Method);
* описывать ожидаемые результаты внутри тестового метода в форме вызовов методов с утверждением (Assertion Method);
* аггрегировать тесты в наборы, которые могут запускаться с помощью одной команды;
* запускать один или несколько тестов для получения отчета о результатах запуска.

Этого достаточно, если речь идет о модульном тестировании (Unit testing). Но для более высокоуровневых тестов, например, проудктовых (Product testing), это не так. Такие тесты могут выполняться часы, в них проверяется много утверждений. В рамках стандартной модели xUnit анализировать результаты таких тестов достаточно проблематично. Например, тест, проверяющий наличие логотипа на заглавной странице сайта, со следующим сценарием:

* открываем браузер;
* переходим страницу сайта;
* находим элемент, содержащий логотип;
* сравниваем найденный логотип с образцом;
* закрываем браузер

может не пройти из-за следующих причин:

* не получилось открыть браузер;
* нет подключения к интернету;
* не получилось перейти на страницу сайта;
* нету элемента, содержащего логотип;
* логотип не совпадает с образцом;
* не получилось закрыть браузер.

В рамках модели xUnit мы получим сообщение об ошибке, по которому будет достаточно сложно понять, что произошло. 
А если разбить тест на шаги (Steps) и добавить к результатам теста скришот сайта, то анализ ошибки не займет много времени.

Отсюда возникает следующая задача: разработать систему, позволяющую агрегировать дополнительную информацию о тестах и отображать ее в отчете о результатах тестов. Система не должна контролировать процесс выполнения самих тестов, а должна предоставлять API адаптации уже написанных тестов.

В данной работе будет описан процесс разработки такой системы. 

Во второй главе, на основании анализа различных систем построения отчетов автотестов, а также опыта написания тестирования, сформулированы основные принципы для организации системы. 

В третьей главе приведена подробная архитектура Allure, позволяющая легко интегрироваться с любыми существующими
тестовыми фремворками и расширять имующийся функционал. Подробно описана интеграция новых фремворков, и новых систем сборки.

В заключении дано описание текущего состояния разработки и перспективы
ее развития.

## Глава 1. Постановка задачи

### 1.1. Термины и понятия

В данном разделе описаны термины, используемые других частях представленной работы. При этом смысл многих 
терминов сужен, по сравнению, с их обычным смыслом. Это связано, с тем, что данная работа ориентирована в
первую очередь, разработку системы построения отчетов автотестов. В дальнейшем приведенные термины будут использоваться в указанных значениях, если не оговорено обратное.

#### 1.1.1. Тестирование

##### Разработка через требования (BDD, behavior-driven development)
Разновидность разработки через тестирование, сфокусированная на тестах в которых четко описаны ожидаемые требования к тестируемой системе. Упор делается на то, что тесты используются как документация работы системы.

##### Фича (feature)
Часть функциональности развивающейся системы, которая может быть протестирована. 

##### Тест (test)
Некоторая процедура, котороая может быть выполена вручную или автоматически, и может быть использована для проверки 
ожидаемых требований к тестируемой системы. Тест часто называют тесткейсом.

##### Тесткейс (test case)
Обычно синоним для понятия "тест". В xUnit это также может обозначать тестовый класс, как место в которое содержит тестовые методы.

##### Контекст теста (test context, test fixture)
Все, что нужно тестируемой системе чтобы мы могли ее протестировать.
Например, наглядно понятно, что такое контекст теста в тестовом фремворке RSpec:

Контекст: множество фруктов содержащих = {яблоко, апельсин, грушу}

Экспертиза: удалим апельсин из множества фруктов

Проверим: множество фруктов содержит = {яблоко, груша}

##### Разработка через тестирование (TDD, test-driven development)

Техника разработки программного обеспечения, которая основывается на повторении очень которких циклов:

* написание теста на новую/изменяемую функциональность;
* имплементация функциональности. Тест должен пройти;
* рефакторинг кода под соответствующие стандарты разработки.

##### Ошибка теста (test error)
Ошибка, возникающая в ходе выполнения теста. Например, ошибка может возникнуть в проверяемой системе,
или в самом тесте. Также ошибка может возникнуть в окружении (например, в операционной системе, виртуальной машине).
Как правило, ошибка в самом тесте, а не в проверяемой системе.

##### Падение теста (test failure) 
Тест падает, когда в проверке утверждений актуальное значение не совпадает с ожидаемым. Обычно означает наличие ошибки в проверяемой системе.

##### Результат теста (test result)
Тест, или тестсуит могут быт ьзапущены несколько раз, и каждый раз возращать различные результаты проверок.

##### Тестран (test run)
Запуск некоторого числа тестов или тестсуитов. После выполнения тестов из тестрана, мы можем получить их результаты.

##### Тест прошел (test success)
Ситуация, в которой проверка каждого утверждения в тесте прошла успешна (актуальные значения совпали с ожидаемыми), и в процессе выполенения теста не произошло никаких ошибок теста.

##### Тестсуит (test suite)
Способ наименования некоторого числа тестов, которые могут быть запущены вместе.

##### Стори (user story, story)
Модуль, часть функциональности, из которых может состоять фича.

##### xUnit 
Под термином "xUnit" подразумевается любой член семейства инфраструктур автоматизации тестов (Test Automation Framework), применяемых для автоматизации созданных вручную сценариев тестов. Для большинства современных языков программирования существует как минимум одна реализация xUnit. Обычно для автоматизации применяется тот же язык, который использовался для написания тестируемой ситстемы. Хотя это не всегда так, использовать подобную стратегию проще, поскольку тесты легко получают доступ к программному интерфейсу тестируемой системы.

Большинство членов xUnit реализованы с использованием объектно-ориентированной парадигмы.

#### 1.2. Обоснование актуальности

В последнее время начало появляться большое количество продуктовых тестов. Только в нашем отделе тестирования в Яндексе ежедневно запускается несколько миллионов таких тестов. Анализировать результаты такого количества тестов очень затруднительно. 

#### 1.3. Обзор существующих систем

* surefire. Содержит простую таблицу с именем теста и его статусом. В случае наличия ошибки есть стектрейс. Для больших запусков (20-30 тысяч тесткейсов) даже открыть отчет затруднительно.

* Thucydides - инструмент для быстрого написания тестов с использованием WebDriver. По стути - набстройка над jUnit. Управляет ходом выполнения тестов, по сути является тестовым фремворком, а не фремворком для построения отчетов. Однако, строит отчет. Минусы - слишком много ограничений: только jUnit, только такой синтаксис, только такая логика поведения тестов, слишком много проблем: постоянные проблемы, возникающие из-за того, что это очень большая сложная система. Отчет содержит допольнительную информацию, в отличие от surefire, и есть возможность разбивать тесты на шаги. Но нет возможности добавлять к тесту произвольную информацию. Также не совсем удобное отображение тестов в отчете.

#### 1.4. Технический и организационный контекст


#### 1.5. Уточненные требования к работе

* Основное требование - отчеты тестов должны быть понятны не только тем людям, которые писали тесты. А так же разработкам (в случае, если тестировщики и разработчики разные люди), менеджерам.
  * Отчет тестов должен уметь отображать сценарий теста
  * Отчет должен оперировать общепринятыми, понятными терминами
  * Отчет должен иметь интуитивно-понятный, простой интерфейс
* Система должны быть простой. У тестировщиков, которые пишут тесты, не достаточно времени и сил, чтобы разбираться в большой и сложной системе. 
* Большое количество разных подходов к тестированию, разных инструментов тестирования. У системы не должно быть проблем совместимости.
* Никто не будет переписывать большое количество уже работающих тестов. Система должна уметь подключаться к тестам как можно проще.
* Должны быть возможность подключать систему к тестам на разных языках программирования.

### Глава 2. Теоритические результаты

#### 2.1. Анализ предыдущих разработок

### Глава 3. Проектирование программного продукта

В ходе разработки проекта была получена следующая архитектура:

* Адаптер
* Модель
* Отчет

#### Адаптер

Адаптер отвечает за сбор информации о ходе выполнения теста. Основные требования – легкое подключение к большому числу уже написанных тестов. Тесты представляют из себя набор тестовых классов (test suite), содержащих один или более тестовых методов (test case), которые, в свою очередь, разбиты на степы (steps). Степы – некоторый набор методов, которые помогают избавиться от дублирования кода, и быстрее понимать, в чем ошибка. 
Чтобы написать адаптер, нужно научиться реализовывать аспекты [5] test suite started, test suite finished, test case started, test case finished, test case failed, test case skipped, step started, step finished и step failed. 

#### Модель

Модель будет состоять из двух уровней. Первый – наиболее лаконичное представление, только те данные, которые нельзя синтезировать, такие как имя теста, результат выполнения, времена начала и конца теста. Второй – более удобная для отображения форма данных, содержащая в себе более полную информацию, такую как, например, время выполнения теста.
Сделано это для того, чтобы избавить адаптеры для разных языков программирования от лишних вычислений.
Для описания модели были использованы XSD-схемы [12], а преобразование между первым и вторым уровнями модели сделано с помощью XSLT [13]. 

#### Отчет

Для решения этой задачи, было решено использовать angularJS [14] и bootstrap [15]. Написание основы полноценного single-page application [16] заняло примерно месяц. Чтобы сгенерировать отчет, достаточно распаковать его и подложить ему папку с моделью.

### Заключение

В даннай работе создан фреймворк для генерации отчетов автотестов. Фремворк легко адапатируется к другим системам.

### Список литературы

1. Gerard Meszaros xUnit Test Patterns: Refactoring Test Code ISBN-13: 978-0131495050
2.	Проект JUnit http://junit.org/
2.	Thucydides - framework для написания web-driver based BDD тестов http://thucydides.info/
3.	JUnit, простой framework для написания тестов. http://junit.org/ 
4.	Система сборки maven http://maven.apache.org/ 
5.	АОП – аспектно-ориентированное программирование. http://ru.wikipedia.org/wiki/Аспектно-ориентированное_программирование
6.	JUnit Rules https://github.com/junit-team/junit/wiki/Rules 
7.	JUnit Test Watcher Rule https://github.com/junit-team/junit/wiki/Rules#testwatchmantestwatcher-rules 
8.	ASM OW2 http://asm.ow2.org/ http://download.forge.objectweb.org/asm/asm4-guide.pdf 
9.	Spring aspects http://docs.spring.io/spring/docs/2.0.8/reference/aop.html 
10.	 Cglib http://cglib.sourceforge.net/ 
11.	 AspectJ http://eclipse.org/aspectj/ 
12.	 JAXB, xsd https://jaxb.java.net/ http://ru.wikipedia.org/wiki/XML_Schema 
13.	 XSLT http://ru.wikipedia.org/wiki/XSLT 
14.	 AngularJS http://angularjs.org/ 
15.	 Bootstrap 3.0 http://getbootstrap.com/
16.	 Single Page Application http://en.wikipedia.org/wiki/Single-page_application 
17.	 Тестовая среда. Как найти общий язык с результатами тестов. http://tech.yandex.ru/events/meetings/testing-environment/talks/1462/ 
18.	 Allure, github https://github.com/allure-framework/allure-core 
19.	 Сайт проекта http://allure.qatools.ru/ 
20.	 Allure, sonar http://sonar.qatools.ru/dashboard/index/419 
21.	 Allure, пример отчета (логин и пароль вводить не нужно, можно залогиниться как гость) http://teamcity.qatools.ru/project.html?projectId=allure&tab=preport_project1_Development_Report 
22.	 Jenkins, ci http://jenkins-ci.org/ 
23.	 Habrahabr. Как сделать свой отчет для автотестов. http://habrahabr.ru/company/yandex/blog/200364/ 
24.	 Allure framefork, github https://github.com/allure-framework?source=c 

### Приложения
